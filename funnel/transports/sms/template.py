from __future__ import annotations

from string import Formatter
from typing import Dict, Optional, Pattern, cast
import re

from flask import Flask

__all__ = [
    'SmsTemplate',
    'WebOtpTemplate',
    'OneLineTemplate',
    'TwoLineTemplate',
    'MessageTemplate',
]

# --- Registered template processor ----------------------------------------------------

# This list of chars is from https://archive.is/XJJHV via Airtel
dlt_exempted_chars_re = re.compile('[~`!@#$%^&*()_+={}\\[\\]|\\\\/:;"\'<>,.? -]')

_var_variant_re = re.compile(r'{\s*#\s*var\s*#\s*}', re.IGNORECASE)
_var_repeat_re = re.compile('({#.*?#})+')

#: The maximum number of characters that can appear under one {#var#}
#: Unclear in documentation: are exempted characters excluded from this length limit?
VAR_MAX_LENGTH = 30


class SmsTemplate:
    """
    SMS template validator and formatter, for DLT registered SMS in India.

    To use, create a subclass with the registered and Python templates, and optionally
    override :meth:process to process variables. The registered and Python templates are
    validated to match each other when the class is created::

        class MyTemplate(SmsTemplate):
            registered_template = "Insert {#var#} here"
            template = "Insert {var} here"

            var: str  # Declare variable type like this

            # Optional processor
            def process(self) -> None:
                assert isinstance(self.var, str)

    The template can be used in a single pass::

        >>> str(MyTemplate(var="sample"))
        'Insert sample here'

    Or it can be constructed one variable at a time::

        >>> msg = MyTemplate()
        >>> msg.var = "sample"
        >>> msg.var
        'sample'
        >>> msg.text
        'Insert sample here'

    Keyword format arguments for the Python template can be set and accessed directly
    from the class instance. The formatted string is available in the :attr:`text`
    property, or by casting the template object to a string.
    """

    #: Registered entity id
    registered_entityid: Optional[str] = None
    #: Registered template id
    registered_templateid: Optional[str] = None
    #: Registered template, using `{#var#}` where variables should appear
    registered_template: str = ""
    #: Python template, with formatting variables as {var}
    template: str = ""

    #: Autogenerated regex version of registered template
    registered_template_re: Optional[Pattern] = None

    # Type hints for mypy
    _text: Optional[str]
    _format_kwargs: Dict[str, object]

    def __init__(self, **kwargs) -> None:
        """Initialize template with variables."""
        object.__setattr__(self, '_text', None)
        object.__setattr__(self, '_format_kwargs', kwargs)

    def process(self) -> None:
        """Process variables (subclasses may override as necessary)."""

    def format(self) -> None:  # noqa: A003
        """Format template with variables."""
        self.process()
        object.__setattr__(self, '_text', self.template.format(**self._format_kwargs))

    @property
    def text(self) -> str:
        if self._text is None:
            self.format()
        # self.format() ensures `_text` is str, but mypy doesn't know
        return cast(str, self._text)

    def validate(self) -> bool:
        """Validate the processed text against the registered template."""
        # TODO: This validator does not check for length limits in {#var#} segments
        return (
            len(self.text) <= 2000
            # validate_template ensures self.registered_template_re is a pattern,
            # but mypy doesn't know
            and cast(Pattern, self.registered_template_re).fullmatch(self.text)
            is not None
        )

    def __str__(self) -> str:
        """Return SMS text as string."""
        return self.text

    def __repr__(self) -> str:
        """Return a representation of self."""
        return f'<{self.__class__.__name__} {self.text!r}>'

    def __getattr__(self, attr):
        """Get a format variable."""
        return self._format_kwargs[attr]

    def __setattr__(self, attr, value):
        """Set a format variable."""
        self._format_kwargs[attr] = value
        object.__setattr__(self, '_text', None)

    @staticmethod
    def base_length(template: str) -> int:
        """Return the base length of a Python template, before content is inserted."""
        return len(''.join([segment[0] for segment in Formatter().parse(template)]))

    @classmethod
    def validate_registered_template(cls) -> None:
        """Validate the Registered template as per documented rules."""
        if len(cls.registered_template) > 2000:
            raise ValueError(
                f"Registered template must be within 2000 chars"
                f" (currently {len(cls.registered_template)} chars)"
            )
        for varmatch in _var_variant_re.findall(cls.registered_template):
            if varmatch != '{#var#}':
                raise ValueError(
                    f"Registered template must use {{#var#}}, not {varmatch}"
                )

    @classmethod
    def validate_template(cls) -> None:
        """Validate that the Python template matches the registered template."""
        # 1. Confirm template does not use format arguments that conflict with class
        #    members.

        for _literal_text, field_name, _format_spec, _conversion in Formatter().parse(
            cls.template
        ):
            if (
                field_name in ('_text', '_format_kwargs')
                or field_name in SmsTemplate.__dict__
            ):
                raise ValueError(
                    f"Template keyword '{field_name}' in {cls.__name__} is reserved and"
                    f" cannot be used"
                )

        # 2. Replace all repetitions of {#var#} in the registered template with a single
        #    reference. Repetitions are required because {#var#} has a length limit of
        #    30 characters, excluding exempted characters. We do not validate length
        #    at this stage, so we don't need the repetitions. (Length validations are
        #    left to the subclass to perform in :meth:`format`.)
        # 3. Convert the registered template into a regex, replacing {#var#} with .*?
        registered_template_re = re.escape(
            _var_repeat_re.sub('{#var#}', cls.registered_template)
        ).replace(
            # re.escape will convert {#var#} to \{\#var\#\}
            r'\{\#var\#\}',
            '.*?',
        )
        # Compile regex and save to class
        cls.registered_template_re = re.compile(registered_template_re)
        # 3. Match regex against Python template
        if cls.registered_template_re.fullmatch(cls.template) is None:
            raise ValueError(
                f"Python template does not match registered template in {cls.__name__}"
                f"\nRegistered template: {cls.registered_template!r}"
                f"\nAs regex: {registered_template_re!r}\n"
                f"\nTemplate: {cls.template!r}"
            )

    @classmethod
    def validate_no_entity_template_id(cls) -> None:
        if cls.registered_entityid is not None or cls.registered_templateid is not None:
            raise TypeError(
                "Registered entity id and template id are not public information and"
                " must be in config. Use init_app to load config"
            )

    def __init_subclass__(cls) -> None:
        """Validate templates in subclasses."""
        super().__init_subclass__()
        cls.validate_no_entity_template_id()
        cls.validate_registered_template()
        cls.validate_template()

    @classmethod
    def init_subclass_config(cls, app: Flask, config: Dict[str, str]) -> None:
        """Recursive init for setting template ids in subclasses."""
        for subcls in cls.__subclasses__():
            subcls_config_name = ''.join(
                ['_' + c.lower() if c.isupper() else c for c in subcls.__name__]
            ).lstrip('_')
            templateid = config.get(subcls_config_name)
            if not templateid:
                # No template id provided. If class already has a templateid from
                # parent class, let this pass. If not, raise a warning.
                if not cls.registered_templateid:
                    app.logger.warning(
                        "App config is missing SMS_DLT_TEMPLATE_IDS['%s'] for template"
                        " %s",
                        subcls_config_name,
                        subcls.__name__,
                    )
            else:
                # Set the template id from config
                subcls.registered_templateid = templateid
            # Recursively configure subclasses of this subclass
            subcls.init_subclass_config(app, config)

    @classmethod
    def init_app(cls, app: Flask) -> None:
        """Set Registered entity id and template ids from app config."""
        cls.registered_entityid = app.config.get('SMS_DLT_ENTITY_ID')
        cls.init_subclass_config(app, app.config.get('SMS_DLT_TEMPLATE_IDS', {}))


# --- Registered templates used by this app --------------------------------------------


class WebOtpTemplate(SmsTemplate):
    """Template for Web OTPs."""

    registered_template = (
        'OTP is {#var#} for Hasgeek.\n\nNot you? Block misuse: {#var#}\n\n'
        '@{#var#} #{#var#}'
    )
    template = (
        'OTP is {otp} for Hasgeek.\n\nNot you? Block misuse: {helpline_text}\n\n'
        '@{domain} #{otp}'
    )


class OneLineTemplate(SmsTemplate):
    """Template for single line messages."""

    registered_template = '{#var#}{#var#}{#var#}{#var#}\n\n{#var#} to stop - Hasgeek'
    template = '{text1} {url}\n\n{unsubscribe_url} to stop - Hasgeek'

    text1: str
    url: str
    unsubscribe_url: str

    # Disabled because {#var#}  length limits aren't enforced

    # def process(self) -> None:
    #     """Process variables."""
    #     # '{text1} {url}' has a length limit of VAR_MAX_LENGTH*4. Truncate text to fit
    #     # -1 is for the space char between text1 and url
    #     max_text_length = VAR_MAX_LENGTH * 4 - 1 - len(self.url)
    #     if len(self.text1) > max_text_length:
    #         self.text1 = self.text1[: max_text_length - 3] + '...'


class TwoLineTemplate(SmsTemplate):
    """Template for double line messages."""

    registered_template = (
        '{#var#}{#var#}\n\n{#var#}{#var#}\n\n{#var#} to stop - Hasgeek'
    )
    template = '{text1}\n\n{text2} {url}\n\n{unsubscribe_url} to stop - Hasgeek'

    text1: str
    text2: str
    url: str
    unsubscribe_url: str

    # Disabled because {#var#}  length limits aren't enforced

    # def process(self) -> None:
    #     """Process variables."""
    #     # '{text1}' and '{text2} {url}' both have a length limit of VAR_MAX_LENGTH*2
    #     max_text1_length = VAR_MAX_LENGTH * 2
    #     # -1 is for the space char between text2 and url
    #     max_text2_length = VAR_MAX_LENGTH * 2 - 1 - len(self.url)
    #     if len(self.text1) > max_text1_length:
    #         self.text1 = self.text1[: max_text1_length - 3] + '...'
    #     if len(self.text2) > max_text2_length:
    #         self.text2 = self.text2[: max_text2_length - 3] + '...'


class MessageTemplate(OneLineTemplate):
    template = '{message}\n\n{unsubscribe_url} to stop - Hasgeek'

    message: str
    unsubscribe_url: str

    # Disabled because {#var#} length limits aren't enforced

    # def process(self) -> None:
    #     """Process variables."""
    #     # '{message}' has a length limit of VAR_MAX_LENGTH*4. Truncate text to fit
    #     max_text_length = VAR_MAX_LENGTH * 4
    #     if len(self.message) > max_text_length:
    #         self.message = self.message[: max_text_length - 3] + '...'
