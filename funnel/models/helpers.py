"""Helpers for models."""

from __future__ import annotations

from dataclasses import dataclass
from textwrap import dedent
from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    Iterable,
    List,
    Optional,
    Set,
    Type,
    TypeVar,
    cast,
)
import os.path
import re

from sqlalchemy.dialects.postgresql import TSQUERY
from sqlalchemy.dialects.postgresql.base import (
    RESERVED_WORDS as POSTGRESQL_RESERVED_WORDS,
)
from sqlalchemy.ext.mutable import MutableComposite
from sqlalchemy.orm import composite

from markupsafe import Markup
from markupsafe import escape as html_escape

from better_profanity import profanity
from furl import furl
from zxcvbn import zxcvbn

from .. import app
from ..typing import T
from ..utils import MarkdownConfig, markdown_escape
from . import UrlType, sa

__all__ = [
    'RESERVED_NAMES',
    'PASSWORD_MIN_LENGTH',
    'PASSWORD_MAX_LENGTH',
    'check_password_strength',
    'profanity',
    'add_to_class',
    'add_search_trigger',
    'visual_field_delimiter',
    'valid_name',
    'valid_username',
    'quote_autocomplete_like',
    'quote_autocomplete_tsquery',
    'ImgeeFurl',
    'ImgeeType',
    'MarkdownCompositeBase',
    'MarkdownCompositeBasic',
    'MarkdownCompositeDocument',
    'MarkdownCompositeInline',
]

RESERVED_NAMES: Set[str] = {
    '_baseframe',
    'about',
    'account',
    'admin',
    'api',
    'app',
    'apps',
    'auth',
    'blog',
    'boxoffice',
    'brand',
    'brands',
    'by',
    'client',
    'clients',
    'comments',
    'confirm',
    'contact',
    'contacts',
    'crew',
    'dashboard',
    'delete',
    'edit',
    'email',
    'emails',
    'embed',
    'event',
    'events',
    'ftp',
    'funnel',
    'funnels',
    'hacknight',
    'hacknights',
    'hgtv',
    'imap',
    'in',
    'json',
    'kharcha',
    'login',
    'logout',
    'members',
    'membership',
    'new',
    'news',
    'notification',
    'notifications',
    'org',
    'organisation',
    'organisations',
    'organization',
    'organizations',
    'orgs',
    'pop',
    'pop3',
    'profile',
    'profiles',
    'project',
    'projects',
    'proposal',
    'proposals',
    'register',
    'reset',
    'search',
    'siteadmin',
    'smtp',
    'sponsors',
    'static',
    'ticket',
    'tickets',
    'token',
    'tokens',
    'update',
    'updates',
    'venue',
    'venues',
    'video',
    'videos',
    'workshop',
    'workshops',
    'www',
}


@dataclass
class PasswordCheckType:
    """
    Return type for :func:`check_password_strength`.

    Includes integer score from zxcvbn:

    * 0: too guessable: risky password
        (guesses < 10^3)
    * 1: very guessable: protection from throttled online attacks
        (guesses < 10^6)
    * 2: somewhat guessable: protection from unthrottled online attacks
        (guesses < 10^8)
    * 3: safely unguessable: moderate protection from offline slow-hash scenario
        (guesses < 10^10)
    * 4: very unguessable: strong protection from offline slow-hash scenario
        (guesses >= 10^10)
    """

    is_weak: bool
    score: int  # One of 0, 1, 2, 3, 4
    warning: str
    suggestions: List[str]


#: Minimum length for a password
PASSWORD_MIN_LENGTH = 8
#: Maximum length for a password
PASSWORD_MAX_LENGTH = 100
#: Strong passwords require a strength of at least 3 as per the zxcvbn
#: project documentation.
PASSWORD_MIN_SCORE = 3


def check_password_strength(
    password: str, user_inputs: Optional[Iterable[str]] = None
) -> PasswordCheckType:
    """Check the strength of a password using zxcvbn."""
    result = zxcvbn(password, user_inputs)
    return PasswordCheckType(
        is_weak=(
            len(password) < PASSWORD_MIN_LENGTH
            or result['score'] < PASSWORD_MIN_SCORE
            or bool(result['feedback']['warning'])
        ),
        score=result['score'],
        warning=result['feedback']['warning'],
        suggestions=result['feedback']['suggestions'],
    )


# re.IGNORECASE needs re.ASCII because of a quirk in the characters it matches.
# https://docs.python.org/3/library/re.html#re.I
_username_valid_re = re.compile('^[a-z0-9][a-z0-9_]*$', re.I | re.A)
_name_valid_re = re.compile('^[a-z0-9]([a-z0-9-]*[a-z0-9])?$', re.A)


# Create a profanity word list by combining the built-in list of the better_profanity
# package (~835 terms) with an additional list (>1300 terms) from
# https://www.cs.cmu.edu/~biglou/resources/ stored here as a static file.
# This list is used to filter autogenerated ids (currently in Shortlink.new)
with open(
    os.path.join(os.path.dirname(__file__), 'bad-words.txt'), encoding='utf-8'
) as badwordfile:
    profanity.add_censor_words([_w.strip() for _w in badwordfile.readlines()])


visual_field_delimiter = ' Â¦ '


def add_to_class(cls: Type, name: Optional[str] = None) -> Callable[[T], T]:
    """
    Add a new method to a class via a decorator. Takes an optional attribute name.

    Usage::

        @add_to_class(ExistingClass)
        def new_method(self, *args):
            pass

        @add_to_class(ExistingClass, 'new_property')
        @property
        def existing_class_new_property(self):
            pass
    """

    def decorator(attr: T) -> T:
        use_name: Optional[str] = name or getattr(attr, '__name__', None)
        if not use_name:  # pragma: no cover
            # None or '' not allowed
            raise ValueError(f"Could not determine name for {attr!r}")
        if use_name in cls.__dict__:
            raise AttributeError(f"{cls.__name__} already has attribute {use_name}")
        setattr(cls, use_name, attr)
        return attr

    return decorator


ReopenedType = TypeVar('ReopenedType', bound=type)
TempType = TypeVar('TempType', bound=type)


def reopen(cls: ReopenedType) -> Callable[[TempType], ReopenedType]:
    """
    Move the contents of the decorated class into an existing class and return it.

    .. deprecated::
        This function is deprecated and should not be used as it is incompatible with
        PEP 484 type hinting.

    Usage::

        @reopen(ExistingClass)
        class __ExistingClass:
            @property
            def new_property(self):
                ...

    This is equivalent to::

        def new_property(self):
            ...

        ExistingClass.new_property = property(new_property)

    This decorator is syntactic sugar to make class extension visually similar to class
    definition. It is not for monkey patching. It will refuse to overwrite existing
    attributes, and will reject a decorated class that contains base classes or a
    metaclass. If the existing class was processed by a metaclass, the new attributes
    added to it may not receive the same processing.

    This decorator is intended to aid legibility of bi-directional relationships in
    SQLAlchemy models, specifically where a basic backref is augmented with methods or
    properties that do more processing.

    """

    def decorator(temp_cls: TempType) -> ReopenedType:
        if temp_cls.__bases__ != (object,):
            raise TypeError("Reopened class cannot add base classes")
        if temp_cls.__class__ is not type:
            raise TypeError("Reopened class cannot add a metaclass")
        if {
            '__slots__',
            '__getattribute__',
            '__getattr__',
            '__setattr__',
            '__delattr__',
        }.intersection(set(temp_cls.__dict__.keys())):
            raise TypeError("Reopened class contains unsupported __attributes__")
        for attr, value in list(temp_cls.__dict__.items()):
            # Skip the standard Python attributes, process the rest
            if attr not in (
                '__dict__',
                '__doc__',
                '__module__',
                '__weakref__',
                '__annotations__',
            ):
                # Refuse to overwrite existing attributes
                if hasattr(cls, attr):
                    raise AttributeError(f"{cls.__name__} already has attribute {attr}")
                # All good? Copy the attribute over...
                setattr(cls, attr, value)
                # ...And remove it from the temporary class
                delattr(temp_cls, attr)
            # Merge typing annotations
            elif attr == '__annotations__':
                cls.__annotations__.update(value)
        # Return the original class. Leave the temporary class to the garbage collector
        return cls

    return decorator


def valid_username(candidate: str) -> bool:
    """
    Check if a username is valid.

    Letters, numbers and underscores only.
    """
    return _username_valid_re.search(candidate) is not None


def valid_name(candidate: str) -> bool:
    """
    Check if a name is valid.

    Lowercase letters, numbers and non-terminal hyphens only.
    """
    return _name_valid_re.search(candidate) is not None


def pgquote(identifier: str) -> str:
    """Add double quotes to the given identifier if required (PostgreSQL only)."""
    return f'"{identifier}"' if identifier in POSTGRESQL_RESERVED_WORDS else identifier


def quote_autocomplete_like(prefix, midway=False) -> str:
    """
    Construct a LIKE query string for prefix-based matching (autocomplete).

    :param midway: Search midway using the ``%letters%`` syntax. This requires a
        trigram index to be efficient

    Usage::

        column.like(quote_autocomplete_like(prefix))

    For case-insensitive queries, add an index on LOWER(column) and use::

        sa.func.lower(column).like(sa.func.lower(quote_autocomplete_like(prefix)))

    This function will return an empty string if the prefix has no content after
    stripping whitespace and special characters. It is prudent to test before usage::

        like_query = quote_autocomplete_like(prefix)
        if like_query:
            # Proceed with query
            query = Model.query.filter(
                sa.func.lower(Model.column).like(sa.func.lower(like_query))
            )
    """
    # Escape the '%' and '_' wildcards in SQL LIKE clauses.
    # Some SQL dialects respond to '[' and ']', so remove them.
    # Suffix a '%' to make a prefix-match query.
    like_query = (
        prefix.replace('%', r'\%').replace('_', r'\_').replace('[', '').replace(']', '')
        + '%'
    )
    lstrip_like_query = like_query.lstrip()
    if lstrip_like_query == '%':
        return ''
    if midway:
        return '%' + like_query
    return lstrip_like_query


def quote_autocomplete_tsquery(prefix: str) -> TSQUERY:
    """Return a PostgreSQL tsquery suitable for autocomplete-type matches."""
    return cast(
        TSQUERY,
        sa.func.cast(
            sa.func.concat(sa.func.phraseto_tsquery('simple', prefix or ''), ':*'),
            TSQUERY,
        ),
    )


def add_search_trigger(
    model: Any, column_name: str  # type: ignore[name-defined]
) -> Dict[str, str]:
    """
    Add a search trigger and returns SQL for use in migrations.

    Typical use::

        class MyModel(db.Model):  # type: ignore[name-defined]
            ...
            search_vector: Mapped[TSVectorType] = sa.orm.deferred(sa.Column(
                TSVectorType(
                    'name', 'title', *indexed_columns,
                    weights={'name': 'A', 'title': 'B'},
                    regconfig='english'
                ),
                nullable=False,
            ))

            __table_args__ = (
                sa.Index(
                    'ix_mymodel_search_vector',
                    'search_vector',
                    postgresql_using='gin'
                ),
            )

        add_search_trigger(MyModel, 'search_vector')

    To extract the SQL required in a migration:

        $ flask shell
        >>> print(models.add_search_trigger(models.MyModel, 'search_vector')['trigger'])

    Available keys: ``update``, ``trigger`` (for migration upgrades) and ``drop`` (for
    migration downgrades).

    :param model: Model class
    :param str column_name: Name of the tsvector column in the model
    """
    column = getattr(model, column_name)
    function_name = model.__tablename__ + '_' + column_name + '_update'
    trigger_name = model.__tablename__ + '_' + column_name + '_trigger'
    weights = column.type.options.get('weights', {})
    regconfig = column.type.options.get('regconfig', 'english')

    trigger_fragments = []
    update_fragments = []

    for col in column.type.columns:
        qcol = pgquote(col)
        # Trigger function expression fragment
        texpr = f"to_tsvector('{regconfig}', COALESCE(NEW.{qcol}, ''))"
        # Update statement expression fragment
        uexpr = f"to_tsvector('{regconfig}', COALESCE({qcol}, ''))"
        if col in weights:
            wcol = weights[col]
            texpr = f"setweight({texpr}, '{wcol}')"
            uexpr = f"setweight({uexpr}, '{wcol}')"
        trigger_fragments.append(texpr)
        update_fragments.append(uexpr)

    #: Combine fragments into a single expression, for use in the trigger function
    trigger_expr = ' || '.join(trigger_fragments)
    #: Combine fragments into a single expression, for use in the update statement
    update_expr = ' || '.join(update_fragments)

    trigger_function = dedent(
        '''
        CREATE FUNCTION {function_name}() RETURNS trigger AS $$
        BEGIN
            NEW.{column_name} := {trigger_expr};
            RETURN NEW;
        END
        $$ LANGUAGE plpgsql;

        CREATE TRIGGER {trigger_name} BEFORE INSERT OR UPDATE ON {table_name}
        FOR EACH ROW EXECUTE PROCEDURE {function_name}();
        '''.format(  # nosec
            function_name=pgquote(function_name),
            column_name=pgquote(column_name),
            trigger_expr=trigger_expr,
            trigger_name=pgquote(trigger_name),
            table_name=pgquote(model.__tablename__),
        )
    )

    update_statement = (
        f'UPDATE {pgquote(model.__tablename__)}'  # nosec
        f' SET {pgquote(column_name)} = {update_expr};'
    )

    drop_statement = dedent(
        f'''
        DROP TRIGGER {pgquote(trigger_name)} ON {pgquote(model.__tablename__)};
        DROP FUNCTION {pgquote(function_name)}();
        '''
    )

    sa.event.listen(
        model.__table__,
        'after_create',
        sa.DDL(trigger_function).execute_if(dialect='postgresql'),
    )

    sa.event.listen(
        model.__table__,
        'before_drop',
        sa.DDL(drop_statement).execute_if(dialect='postgresql'),
    )

    return {
        'trigger': trigger_function,
        'update': update_statement,
        'drop': drop_statement,
    }


class MessageComposite:
    """
    Mimic MarkdownComposite for static messages.

    :param text: Message text
    :param tag: Optional wrapper tag for HTML rendering
    """

    def __init__(self, text: str, tag: Optional[str] = None):
        self.text = text
        self.tag = tag

    def __markdown__(self) -> str:
        """Return Markdown source (for escaper)."""
        return markdown_escape(self.text)

    def __html__(self) -> str:
        """Return HTML version of string."""
        # Localize lazy string on demand
        tag = self.tag
        if tag:
            return f'<p><{tag}>{html_escape(self.text)}</{tag}></p>'
        return f'<p>{html_escape(self.text)}</p>'

    @property
    def html(self) -> Markup:
        return Markup(self.__html__())

    def __json__(self) -> Dict[str, Any]:
        """Return JSON-compatible rendering of contents."""
        return {'text': self.text, 'html': self.__html__()}


class ImgeeFurl(furl):
    """Furl with a resize method specifically for Imgee URLs."""

    def resize(self, width: int, height: Optional[int] = None) -> furl:
        """
        Return image url with `?size=WxH` suffixed to it.

        :param width: Width to resize the image to
        :param height: Height to resize the image to
        """
        if self.url:
            copy = self.copy()
            copy.args['size'] = f'{width}' if height is None else f'{width}x{height}'
            return copy
        return self


class ImgeeType(UrlType):  # pylint: disable=abstract-method
    """Column that stores an Imgee URL and casts the content into :class:`ImgeeFurl`."""

    url_parser = ImgeeFurl
    cache_ok = True

    def process_bind_param(self, value, dialect):
        value = super().process_bind_param(value, dialect)
        if value:
            allowed_domains = app.config.get('IMAGE_URL_DOMAINS', [])
            allowed_schemes = app.config.get('IMAGE_URL_SCHEMES', [])
            parsed = self.url_parser(value)
            if allowed_domains and parsed.host not in allowed_domains:
                raise ValueError(
                    f"Image must be hosted on {' or '.join(allowed_domains)}"
                )
            if allowed_schemes and parsed.scheme not in allowed_schemes:
                raise ValueError("Invalid scheme for the URL")
        return value


class MarkdownCompositeBase(MutableComposite):
    """Represents Markdown text and rendered HTML as a composite column."""

    config: ClassVar[MarkdownConfig]

    def __init__(self, text, html=None):
        """Create a composite."""
        if html is None:
            self.text = text  # This will regenerate HTML
        else:
            self._text = text
            self._html = html

    # Return column values for SQLAlchemy to insert into the database
    def __composite_values__(self):
        """Return composite values."""
        return (self._text, self._html)

    # Return a string representation of the text (see class decorator)
    def __str__(self):
        """Return string representation."""
        return self._text or ''

    def __markdown__(self):
        """Return source Markdown (for escaper)."""
        return self._text or ''

    # Return a HTML representation of the text
    def __html__(self):
        """Return HTML representation."""
        return self._html or ''

    # Return a Markup string of the HTML
    @property
    def html(self):
        """Return HTML as a read-only property."""
        return Markup(self._html) if self._html is not None else None

    @property
    def text(self):
        """Return text as a property."""
        return self._text

    @text.setter
    def text(self, value):
        """Set the text value."""
        self._text = None if value is None else str(value)
        self._html = self.config.render(self._text)
        self.changed()

    def __json__(self) -> Dict[str, Optional[str]]:
        """Return JSON-compatible rendering of composite."""
        return {'text': self._text, 'html': self._html}

    # Compare text value
    def __eq__(self, other):
        """Compare for equality."""
        return isinstance(other, self.__class__) and (
            self.__composite_values__() == other.__composite_values__()
        )

    def __ne__(self, other):
        """Compare for inequality."""
        return not self.__eq__(other)

    # Pickle support methods implemented as per SQLAlchemy documentation, but not
    # tested here as we don't use them.
    # https://docs.sqlalchemy.org/en/13/orm/extensions/mutable.html#id1

    def __getstate__(self):
        """Get state for pickling."""
        # Return state for pickling
        return (self._text, self._html)

    def __setstate__(self, state):
        """Set state from pickle."""
        # Set state from pickle
        self._text, self._html = state
        self.changed()

    def __bool__(self):
        """Return boolean value."""
        return bool(self._text)

    @classmethod
    def coerce(cls, key, value):
        """Allow a composite column to be assigned a string value."""
        return cls(value)

    @classmethod
    def create(
        cls, name: str, deferred: bool = False, group: Optional[str] = None, **kwargs
    ):
        """Create a composite column and backing individual columns."""
        return composite(
            cls,
            sa.Column(name + '_text', sa.UnicodeText, **kwargs),
            sa.Column(name + '_html', sa.UnicodeText, **kwargs),
            deferred=deferred,
            group=group or name,
        )


class MarkdownCompositeBasic(MarkdownCompositeBase):
    """Markdown composite columns with support for basic CommonMark."""

    config = MarkdownConfig.registry['basic']


class MarkdownCompositeDocument(MarkdownCompositeBase):
    """Markdown composite columns with support for all features."""

    config = MarkdownConfig.registry['document']


class MarkdownCompositeInline(MarkdownCompositeBase):
    """Markdown composite columns with support for inline markup only."""

    config = MarkdownConfig.registry['inline']
